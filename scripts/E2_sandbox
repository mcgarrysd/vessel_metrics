#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb  1 12:02:15 2022

E2_sandbox

@author: sean
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import vessel_metrics as vm
import glob, os
from cv2_rolling_ball import subtract_background_rolling_ball
from skimage.filters import meijering, hessian, frangi, sato
from skimage.morphology import skeletonize
from scipy.stats import ttest_ind

data_path = '/home/sean/Documents/vm_manuscript/SE1_IWR_treatment/data/'

label_list = []
im_list = []
data_files = os.listdir(data_path)

class_list = []
for file in data_files:
    if 'DMSO' in file:
        class_list.append('DMSO')
    else:
        class_list.append('IWR')
    label_list.append(cv2.imread(data_path+file+'/label.png',0))
    im_list.append(cv2.imread(data_path+file+'/img.png',0))
 
seg_list = []
seg_count_auto_list = []
seg_count_manual_list = []
vd_manual_list = []
vd_auto_list = []
bpd_auto_list = []
bpd_manual_list = []
vessel_length_auto = []
vessel_length_manual = []
length_list_a = []
length_list_m = []
bpd_a_nz = []
bpd_m_nz = []
mean_length_auto = []
mean_length_manual = []
count = 0
for im, label in zip(im_list, label_list):
    print(count)
    seg = vm.brain_seg(im)
    seg_list.append(seg.astype(np.uint8))
    
    label[label>0] = 1
    auto_skel = skeletonize(seg)
    edges_a, bp_a = connect_segments(auto_skel)
    
    manual_skel = skeletonize(label)
    edges_m, bp_m = connect_segments(manual_skel)
    
    #edges_m, bp_m = vm.find_branchpoints(manual_skel)
    seg_count_m, edge_labels_m = cv2.connectedComponents(edges_m)
    
    #edges_a, bp_a = vm.find_branchpoints(auto_skel)
    seg_count_a, edge_labels_a = cv2.connectedComponents(edges_a)
    
    seg_count_auto_list.append(seg_count_a)
    seg_count_manual_list.append(seg_count_m)
    
    _, vessel_density_m = vm.vessel_density(im, label, 16, 16)
    _, vessel_density_a = vm.vessel_density(im, seg, 16, 16)
    
    vessel_density_m = np.array(vessel_density_m)
    vessel_density_a = np.array(vessel_density_a)
    
    vessel_density_m_mean = np.mean(vessel_density_m[vessel_density_m>0])
    vessel_density_a_mean = np.mean(vessel_density_a[vessel_density_a>0])
    
    vd_manual_list.append(vessel_density_m_mean)
    vd_auto_list.append(vessel_density_a_mean)
    
    bp_density_a = vm.branchpoint_density(auto_skel, seg)
    bp_density_m = vm.branchpoint_density(manual_skel, label)
    
    bpd_num_zeros_a = np.count_nonzero(bp_density_a == 0)
    bpd_num_zeros_m = np.count_nonzero(bp_density_m == 0)
    
    bpd_a_nz.append(bpd_num_zeros_a)
    bpd_m_nz.append(bpd_num_zeros_m)
    
    bpd_auto_list.append(np.mean(bp_density_a[np.nonzero(bp_density_a)]))
    bpd_manual_list.append(np.mean(bp_density_m[np.nonzero(bp_density_m)]))
    
    _, length_auto = vm.vessel_length(edge_labels_a)
    _, length_manual = vm.vessel_length(edge_labels_m)
    
    mean_length_auto.append(np.mean(length_auto))
    mean_length_manual.append(np.mean(length_manual))
    
    count+=1
dmso_inds = []
iwr_inds = []
for i in range(len(class_list)):
    if class_list[i] == 'DMSO':
        dmso_inds.append(i)
    else:
        iwr_inds.append(i)

seg_count_iwr = [seg_count_auto_list[i] for i in iwr_inds]
seg_count_dmso = [seg_count_auto_list[i] for i in dmso_inds]

bpd_iwr = [bpd_auto_list[i] for i in iwr_inds]
bpd_dmso = [bpd_auto_list[i] for i in dmso_inds]

bpd_0_iwr = [bpd_a_nz[i] for i in iwr_inds]
bpd_0_dmso = [bpd_a_nz[i] for i in dmso_inds]

vd_iwr = [vd_auto_list[i] for i in iwr_inds]
vd_dmso = [vd_auto_list[i] for i in dmso_inds]

length_iwr = [mean_length_auto[i] for i in iwr_inds]
length_dmso = [mean_length_auto[i] for i in dmso_inds]

_,p_seg = ttest_ind(seg_count_iwr, seg_count_dmso)
_,p_bpd = ttest_ind(bpd_iwr, bpd_dmso)
_,p_bpd0 = ttest_ind(bpd_0_iwr, bpd_0_dmso)
_,p_vd = ttest_ind(vd_iwr, vd_dmso)
_,p_len = ttest_ind(length_iwr, length_dmso)

_,p_seg_all = ttest_ind(seg_count_auto_list, seg_count_manual_list)
_,p_vd_all = ttest_ind(vd_auto_list, vd_manual_list)
_,p_bpd_all = ttest_ind(bpd_auto_list, bpd_manual_list)
_,p_bpd0_all = ttest_ind(bpd_a_nz, bpd_m_nz)
_,p_len_all = ttest_ind(mean_length_auto, mean_length_manual)



skel = manual_skel
def connect_segments(skel):
    skel = np.pad(skel,50)
    edges, bp = vm.find_branchpoints(skel)
    _,edge_labels = cv2.connectedComponents(edges)
    
    edge_labels[edge_labels!=0]+=1
    bp_el = edge_labels+bp
    
    _, bp_labels = cv2.connectedComponents(bp)
    unique_bp = np.unique(bp_labels)
    unique_bp = unique_bp[1:]
    
    bp_list = []
    bp_connections = []
    new_edges = np.zeros_like(skel)
    new_bp = np.zeros_like(skel)
    for i in unique_bp:
        #print('branch point ' + str(i))
        temp_bp = np.zeros_like(bp_labels)
        temp_bp[bp_labels == i] = 1
        bp_size = np.sum(temp_bp)
        if bp_size>1:
            branchpoint_viz = deepcopy(edge_labels)
            branchpoint_viz = temp_bp*300 + branchpoint_viz
            
            this_bp_inds = np.argwhere(temp_bp == 1)
            
            connected_segs = []
            bp_coords = []
            for x,y in this_bp_inds:
                bp_neighbors = bp_el[x-1:x+2,y-1:y+2]
                if np.any(bp_neighbors>1):
                    connections = bp_neighbors[bp_neighbors>1].tolist()
                    num_connections = np.size(connections)
                    connected_segs.append(connections)
                    bp_coords.extend(itertools.repeat((x,y),num_connections))
            bp_list.append(i)
            bp_connections.append(connected_segs)
            connected_segs = flatten(connected_segs)
            
            vx = []
            vy = []
            for seg in connected_segs:
                #print('segment ' + str(seg))
                temp_seg = np.zeros_like(bp_labels)
                temp_seg[edge_labels == seg] = 1
                endpoint_im = vm.find_endpoints(temp_seg)
                endpoints = np.argwhere(endpoint_im>0)
                if np.size(endpoints):
                    line = cv2.fitLine(endpoints,cv2.DIST_L2,0,0.1,0.1)
                    vx.append(float(line[0]))
                    vy.append(float(line[1]))
                
            vx = np.array(vx).flatten().tolist()
            vy = np.array(vy).flatten().tolist()
            
            
            v_r = list(zip(np.round(vx,3), np.round(vy,3)))
            slope_tolerance = 0.1
            
            inds = list(range(len(v_r)))
            pair_inds = list(itertools.combinations(inds, 2))
            count = 0
            match = []
            for x,y in itertools.combinations(v_r, 2):
                if np.abs(x[0] - y[0])<slope_tolerance:
                    if np.abs(x[1]-y[1])<slope_tolerance:
                      match = pair_inds[count]
                      print('match')
                count+=1
                
            if match:
                c1 = bp_coords[match[0]]
                c2 = bp_coords[match[1]]
                connected_pts = list(bresenham(c1[0],c1[1],c2[0],c2[1]))
                temp_edges = np.zeros_like(bp_labels)
                temp_bp = np.zeros_like(bp_labels)
                for x,y in connected_pts:
                    temp_edges[x,y] = 1
                new_edges = new_edges+temp_edges
                for x,y in this_bp_inds:
                    if temp_edges[x,y] == 0:
                        bp_neighbors = edges[x-1:x+2,y-1:y+2]
                        if np.any(bp_neighbors>0):
                            temp_bp[x,y] = 1
                new_bp = temp_bp+new_bp
            else:
                new_bp = new_bp + temp_bp
        else:
            new_bp = new_bp + temp_bp
    new_edges = new_edges + edges 
    xdim, ydim = np.shape(skel)
    
    new_edges = new_edges[50:xdim-50, 50:ydim-50]
    new_bp = new_bp[50:xdim-50, 50:ydim-50]
    
    new_bp = new_bp.astype(np.uint8)
    new_edges = new_edges.astype(np.uint8)
    return new_edges, new_bp



