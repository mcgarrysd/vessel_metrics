#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 11 10:02:16 2022

@author: sean
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import vessel_metrics as vm
import glob, os
import pandas as pd
from cv2_rolling_ball import subtract_background_rolling_ball
from skimage.filters import meijering, hessian, frangi, sato
from skimage.morphology import skeletonize
from scipy.stats import ttest_ind

data_path = '/media/sean/SP PHD U3/from_home/ordan_test/' 
im_name = 'control_1.png'

im = cv2.imread(data_path+im_name,0)

plt.figure(); plt.imshow(im)

preproc = vm.preprocess_seg(im)
plt.figure(); plt.imshow(preproc)

seg = vm.brain_seg(im, sigmas = range(1,5,1), filter = 'meijering', thresh = 20, preprocess = False)
vm.overlay_segmentation(im, seg)

sigmas = range(1,5,1)

seg_nt = vm.seg_no_thresh(im.astype(np.uint8), sigmas = range(1,5,1), filter = 'meijering')

plt.figure(); plt.imshow(seg_nt)
enhanced_im = vm.jerman(preproc, sigmas = range(1,8,1), tau = 0.75, brightondark = False, cval=0, mode = 'reflect')

plt.figure(); plt.imshow(enhanced_im)

im_demean = subtract_local_mean(im, size = 8)
seg_test = vm.brain_seg(im_demean, sigmas = range(1,8,1), filter = 'jerman', thresh = 20, preprocess = False)
vm.overlay_segmentation(im, seg_test)

def subtract_local_mean(im,size = 8):
    y_stop = False
    x_stop = False
    num_steps_x = np.floor(im.shape[0]/size).astype(np.uint8)
    num_steps_y = np.floor(im.shape[1]/size).astype(np.uint8)
    output = np.zeros_like(im).astype(np.float16)
    for x in range(num_steps_x):
        x_start = x*size
        x_step = x_start+size
        
        for y in range(num_steps_y):
            y_start = y*size
            y_step = y_start+size
            if y_step>im.shape[1]:
                y_stop = True
            if x_step>im.shape[0]:
                x_stop = True
            if x_stop == True:
                x_step = im.shape[0]
            if y_stop == True:
                y_step = im.shape[1]
            im_tile = im[x_start:x_step,y_start:y_step]
            mean_val = np.mean(im_tile)
            output[x_start:x_step,y_start:y_step] = im_tile-mean_val
    output[output<0]=0
    output = np.round(output).astype(np.uint8)
    return output
            

